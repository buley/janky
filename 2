#!/usr/bin/env node
var path = require('path')
, fs = require('fs')
, file = ''
, stream = fs.createReadStream( path.normalize( process.argv[ 3 ] ) )
, fps = process.argv[ 2 ]
, output = process.argv[ 4 ]
, gauss = require('gauss')
, Table = require('cli-table')
, types = {}
, children_types = {}
, all_frames = []
, good_frames = []
, bad_frames = []
, between_frames = []
, in_frames = [];

if ( '30' === fps) {
  fps = 33;
} else if ('60' === fps) {
  fps = 60;
}
stream.on( 'data', function(data) {
	file += data.toString();
} );
stream.on( 'end', function() {
	stream = JSON.parse( file );
	var x = 0, xlen = stream.length, jank_items = {}, previous_item = null, total_items = 0, total_delay = 0, max_delay = 0, min_delay = 100;
    for(; x < xlen; x += 1) {
		var since_item = 0, between_item = 0, in_item = 0, item_key = null;
        item = stream[ x ];
		if ( null !== previous_item ) {
			in_item = item.endTime - item.startTime;
			all_frames.push( in_item );
			between_item = item.startTime - previous_item.endTime;
			between_frames.push( between_item );
		}
		var chain = [];
		var delay = in_item - fps;
		if ( delay > 0 ) {
			bad_frames.push( in_item );
			total_items++;
			total_delay += delay;
			if( delay > max_delay ) {
				max_delay = delay;
			}
			if( delay < min_delay ) {
				min_delay = delay;
			}
			z = 0, zitems = item.children || [], zlen = zitems.length, chain = [];
			for(; z < zlen; z += 1 ) {
				ch = zitems[ z ];
				chain.push(ch.type)
			}
			if( chain.length === 0 ) {
				previous_item = item;
				continue;
			}
			item_key = chain.join(' -> ')
			if ('undefined' === typeof jank_items[ item_key ] ) {
				jank_items[ item_key ] = {};
				jank_items[ item_key ].count = 1;
				jank_items[ item_key ].children = {};
			} else {
				jank_items[ item_key ].count++;
			}
		} else {
			good_frames.push( in_item );
			previous_item = item;
			continue;
		}
		jank_children = jank_items[ item_key ].children;
		var children = item.children, y = 0, ylen = ( 'undefined' !== typeof children ) ? children.length : 0, previous_child = null, child = null;
	    for(; y < ylen; y += 1) {
			child = children[ y ];
			var since_child = 0, between_child = 0;
			if ( null !== previous_child ) {
				since_child = child.endTime - previous_child.endTime;
				between_child = child.startTime - previous_child.endTime;
				if( !isNaN( since_child ) ) {
					if( since_child > fps ) {
						z = 0, zitems = item.children || [], zlen = zitems.length, chain = [], child_key = null;
						for(; z < zlen; z += 1 ) {
							ch = zitems[ z ];
							child_key = ch.type;
							if ('undefined' === typeof jank_items[ child_key ] ) {
								jank_children[ child_key ] = 1;
							} else {
								jank_children[ child_key ]++;
							}
						}
					}
				}
			}
			previous_child = child;
		}
		previous_item = item;
	}
	/*console.log("COUNT", total_items );
	console.log("DELAY", total_delay );
	console.log("AVG", total_delay / total_items );
	console.log("MAX", max_delay );
	console.log("MIN", min_delay );
	console.log("ALL", all_frames.length, all_frames);
	console.log("BAD", bad_frames.length, bad_frames);
	console.log("GOOD", good_frames.length, good_frames);*/
	var finished_data = {
		all: null,
		bad: null,
		good: null
	};

	var do_all = function() {
		var _all_frames = new gauss.Vector( all_frames );
		_all_frames.min( function(min) {
			console.log("MIN", min);
			_all_frames.max( function(max) {
				console.log("MAX", max);
				_all_frames.mean( function(mean) {
					console.log("MEAN", mean);
					_all_frames.median( function(median) {
						console.log("MEDIAN", median);
						_all_frames.median( function(range) {
							console.log("RANGE", range);
							_all_frames.variance( function(variance) {
								console.log("VARIANCE", variance);
								_all_frames_floored = _all_frames.map( function(frame) { return Math.floor( frame ) } );
								_all_frames_floored.distribution( 'absolute', function(distribution) {
									console.log("DISTRIBUTION", distribution);
									_all_frames.quantile( function(quantile) {
										console.log("QUANTILE", quantile);
										_all_frames.sma( function(sma) {
											console.log("MOVING AVERAGE", sma);
											finished_data.all = {
												min: min,
												max: max,
												mode: mode,
												mean: mean,
												median: median,
												range: range,
												variance: variance,
												distribution: distribution,
												quantile: quantile,
												sma: sma
											};
											console.log('finished all');
											do_good();
										} );
									} );
								} );
							} );
						} );
					} );
				} );
			} );
		} );
	};

	var do_good = function() {
		var _good_frames = new gauss.Vector( good_frames );
		_good_frames.min( function(min) {
			console.log("MIN", min);
			_good_frames.max( function(max) {
				console.log("MAX", max);
				_good_frames.mean( function(mean) {
					console.log("MEAN", mean);
					_good_frames.median( function(median) {
						console.log("MEDIAN", median);
						_good_frames.median( function(range) {
							console.log("RANGE", range);
							_good_frames.variance( function(variance) {
								console.log("VARIANCE", variance);
								_good_frames_floored = _good_frames.map( function(frame) { return Math.floor( frame ) } );
								_good_frames_floored.distribution( 'absolute', function(distribution) {
									console.log("DISTRIBUTION", distribution);
									_good_frames.quantile( function(quantile) {
										console.log("QUANTILE", quantile);
										_good_frames.sma( function(sma) {
											console.log("MOVING AVERAGE", sma);
											finished_data.good = {
												min: min,
												max: max,
												mode: mode,
												mean: mean,
												median: median,
												range: range,
												variance: variance,
												distribution: distribution,
												quantile: quantile,
												sma: sma
											};										
											console.log('finished good');
											do_bad();
										} );
									} );
								} );
							} );
						} );
					} );
				} );
			} );
		} );
	};

	var do_bad = function() {
		var _bad_frames = new gauss.Vector( bad_frames );
		_bad_frames.min( function(min) {
			console.log("MIN", min);
			_bad_frames.max( function(max) {
				console.log("MAX", max);
				_bad_frames.mean( function(mean) {
					console.log("MEAN", mean);
					_bad_frames.median( function(median) {
						console.log("MEDIAN", median);
						_bad_frames.median( function(range) {
							console.log("RANGE", range);
							_bad_frames.variance( function(variance) {
								console.log("VARIANCE", variance);
								_bad_frames_floored = _bad_frames.map( function(frame) { return Math.floor( frame ) } );
								_bad_frames_floored.distribution( 'absolute', function(distribution) {
									console.log("DISTRIBUTION", distribution);
									_bad_frames.quantile( function(quantile) {
										console.log("QUANTILE", quantile);
										_bad_frames.sma( function(sma) {
											console.log("MOVING AVERAGE", sma);
											finished_data.bad = {
												min: min,
												max: max,
												mode: mode,
												mean: mean,
												median: median,
												range: range,
												variance: variance,
												distribution: distribution,
												quantile: quantile,
												sma: sma
											};
											console.log('finished bad');
											do_output();								
										} );
									} );
								} );
							} );
						} );
					} );
				} );
			} );
		} );
	};

	var do_output = function() {
		console.log("FINISHED");
		var table = new Table( {
			head: [ 'Type', 'Min', 'Max', 'Mean', 'Median', 'Mode', 'Range', 'Variance', 'Moving Average' ],
			colWidths: [ 100, 100, 100, 100, 100, 100, 100, 100, 100 ]
		} );
		for( var type in finished_data ) {
			if( finished_data.hasOwnProperty( type ) ) {
				obj = finished_data[ type ];
				table.push( 
					[ type, obj.min, obj.max, obj.mean, obj.median, obj.mode, obj.range, obj.variance, obj.sma ]
				);
			}
		}
		if ( 'string' === typeof output && '' !== output ) {
			fs.writeFile( output, table.toString() );
		} else {
			console.log( table.toString() );
			console.log("### DISTRIBUTION ###");
			console.log( 'all', finished_data.all.distribution );
			console.log( 'good', finished_data.good.distribution );
			console.log( 'bad', finished_data.bad.distribution );
			console.log("### QUANTILE ###");
			console.log( 'all', finished_data.all.quantile );
			console.log( 'good', finished_data.good.quantile );
			console.log( 'bad', finished_data.bad.quantile );
		}		
	};

	console.log('starting');
	do_all();
} );
